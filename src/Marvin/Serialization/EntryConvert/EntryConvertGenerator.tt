<#@ template debug="true" language="C#" #>
<#@ assembly name="$(TargetPath)" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Marvin.Serialization" #>
<#@ import namespace="System.IO" #>
<#@ output extension=".cs" #>
<#
var ignoredValues = new[] { EntryValueType.Class, EntryValueType.Collection, EntryValueType.String, EntryValueType.Enum, EntryValueType.Exception, EntryValueType.Stream }
						.Select(v => v.ToString("G")).ToArray();
var nonFormatProviderParsing = new[] { EntryValueType.Boolean }
								.Select(v => v.ToString("G")).ToArray();
#>
using System;
using System.Collections;
using System.IO;

namespace Marvin.Serialization
{
    /// <summary>
    /// Helper class to converts types to enum and vice versa
    /// </summary>
    public static partial class EntryConvert
    {
        /// <summary>
        /// Transform type of entry
        /// </summary>
        /// <returns>Enum representation of the property type</returns>
        public static EntryValueType TransformType(Type propertyType)
        {
			var valueType = EntryValueType.String;
<#
    var first = true;
    foreach (var enumValue in Enum.GetNames(typeof(EntryValueType)).Where(v => !ignoredValues.Contains(v)))
    {
#>
			<#= first ? string.Empty : "else " #>if (propertyType == typeof(<#= enumValue #>))
			{
				valueType = EntryValueType.<#= enumValue #>;
			}
<#
        first = false;
    }
#>
            else if (propertyType.IsEnum)
            {
                valueType = EntryValueType.Enum;
            }
			else if (typeof(Stream).IsAssignableFrom(propertyType))
			{
			    valueType = EntryValueType.Stream;
			}
            else if (typeof(IEnumerable).IsAssignableFrom(propertyType) && propertyType != typeof(string))
            {
                valueType = EntryValueType.Collection;
            }
            else if (propertyType.IsClass && propertyType != typeof(string))
            {
                valueType = EntryValueType.Class;
            }
            return valueType;
        }

        /// <summary>
        /// Transform string to typed object based on the type value
        /// </summary>
        /// <param name="type">Desired property type</param>
        /// <param name="value">String value</param>
		/// <param name="formatProvider"><see cref="IFormatProvider"/> used for parsing value</param>
        /// <returns>Typed object with parsed value</returns>
        public static object ToObject(Type type, string value, IFormatProvider formatProvider)
        {
            // Traditional re-transformation
            object result = null;
			if (type == typeof(string))
			{
				result = value;
			}
<#
    foreach (var enumValue in Enum.GetNames(typeof(EntryValueType)).Where(v => !ignoredValues.Contains(v)))
    {
#>
			else if (type == typeof(<#= enumValue #>))
			{
<#
		if(!nonFormatProviderParsing.Contains(enumValue))
		{
#>
				result = <#= enumValue #>.Parse(value, formatProvider);
<#
		}
		else
		{
#>
				result = <#= enumValue #>.Parse(value);
<#
		}
#>
			}
<#
    }
#>
			else if (type.IsEnum)
            {
                result = Enum.Parse(type, value);
            }

            return result;
        }

		/// <summary>
        /// Transform string to typed object based on the type enum value
        /// </summary>
        /// <param name="type">Entry value type</param>
        /// <param name="value">String value</param>
		/// <param name="formatProvider"><see cref="IFormatProvider"/> used for parsing value</param>
        /// <returns>Typed object with parsed value</returns>
        public static object ToObject(EntryValueType type, string value, IFormatProvider formatProvider)
        {
            // Traditional re-transformation
            object result = null;
			switch (type)
			{
				case EntryValueType.String:
					result = value;
					break;
<#
    foreach (var enumValue in Enum.GetNames(typeof(EntryValueType)).Where(v => !ignoredValues.Contains(v)))
    {
#>
				case EntryValueType.<#= enumValue #>:
<#
		if(!nonFormatProviderParsing.Contains(enumValue))
		{
#>
					result = <#= enumValue #>.Parse(value, formatProvider);
<#
		}
		else
		{
#>
					result = <#= enumValue #>.Parse(value);
<#
		}
#>
					break;
<#
    }
#>
            }

            return result;
        }
    }
}