//------------------------------------------------------------------------------
// This is auto-generated code.
//------------------------------------------------------------------------------
// This code was generated by Entity Developer tool using the Marvin template for generating Repositories and a Unit of Work for Entity Framework.
// If you have any questions or suggestions for improvement regarding this code, contact Thomas Fuchs. I allways need feedback to improve.
//
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated. So even when you think you can do better,
// don't touch it.
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Data.Entity.Core.EntityClient;
using System.Diagnostics;
using System.Text;
using Devart.Data.PostgreSql;
using System.Data.Entity.Core.Objects;
using System.Data.Entity;
using Marvin.Modules;
using Marvin.Configuration;
using Marvin.Model;

namespace Marvin.TestTools.Test.Model
{
    /// <summary>
    /// Factory to get a unit of work for the TestModel model
    /// </summary>
    public class InMemoryUnitOfWorkFactory : IUnitOfWorkFactory, IParentFactory, IInitializable
    {
        private readonly string _instanceId;
        private string _connectionString;
        private readonly Dictionary<string, IUnitOfWorkFactory> _children = new Dictionary<string, IUnitOfWorkFactory>();

        /// <summary>
        /// Repository builder dictionary, to create new instances of 
        /// </summary>
        private static readonly Dictionary<Type, RepoBuilder> RepoBuilders = new Dictionary<Type, RepoBuilder>
        {
            { typeof(IHugePocoRepository), HugePocoRepository.Create },
            { typeof(IRepository<HugePoco>), HugePocoRepository.Create },
            { typeof(IRecursiveReferenceRepository), RecursiveReferenceRepository.Create },
            { typeof(IRepository<RecursiveReference>), RecursiveReferenceRepository.Create },
            { typeof(ITopParentRepository), TopParentRepository.Create },
            { typeof(IRepository<TopParent>), TopParentRepository.Create },
            { typeof(IJsonTesterRepository), JsonTesterRepository.Create },
            { typeof(IRepository<JsonTester>), JsonTesterRepository.Create },
            { typeof(IBaseClassRepository), BaseClassRepository.Create },
            { typeof(IRepository<BaseClass>), BaseClassRepository.Create },
            { typeof(IInheritedRepository), InheritedRepository.Create },
            { typeof(IRepository<Inherited>), InheritedRepository.Create },
            { typeof(IReferenceBaseRepository), ReferenceBaseRepository.Create },
            { typeof(IRepository<ReferenceBase>), ReferenceBaseRepository.Create },
            { typeof(IARepository), ARepository.Create },
            { typeof(IRepository<A>), ARepository.Create },
            { typeof(IBRepository), BRepository.Create },
            { typeof(IRepository<B>), BRepository.Create },
         };

        /// <summary>
        /// ConfigurationManager to get the connection settings through the database.
        /// Will be injected!
        /// </summary>
        public IConfigManager ConfigManager { get; set; }

        /// <summary>
        /// Static instance for internal usage
        /// </summary>
        internal static InMemoryUnitOfWorkFactory Instance { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="InMemoryUnitOfWorkFactory"/> class.
        /// </summary>
        public InMemoryUnitOfWorkFactory()
        {
            
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InMemoryUnitOfWorkFactory"/> class.
        /// </summary>
        /// <param name="instanceId">The in-memory database will be created under the given instance identifier to seperated created models</param>
        public InMemoryUnitOfWorkFactory(string instanceId)
        {
            if (string.IsNullOrEmpty(instanceId))
                throw new ArgumentException("InstanceId should be not null or empty", "instanceId");

            _instanceId = instanceId;
        }

        /// <summary>
        /// Prepare to use the factory to get a unit of work.
        /// Called by the IoC container.
        /// </summary>
        public void Initialize()
        {
            // Read config and build connection string
            ReloadConfiguration();

            // Set static for internal access
            Instance = this;
        }

        /// <summary>
        /// Load the current configurations and build the connection string 
        /// through the configured database.
        /// </summary>
        public void ReloadConfiguration()
        {
            _connectionString = BuildConnectionString(null);
        }

        /// <summary>
        /// Build a connection string from config
        /// </summary>
        /// <param name="databaseConfig"></param>
        /// <returns></returns>
        private static string BuildConnectionString(IDatabaseConfig databaseConfig)
        {
            // Read given config and create connection string
            var conStringBuilder = new EntityConnectionStringBuilder
            {
                Metadata = "res://*/Marvin.TestTools.Test.Model.Model.TestModel.csdl|" +
                           "res://*/Marvin.TestTools.Test.Model.Model.TestModel.ssdl|" +
                           "res://*/Marvin.TestTools.Test.Model.Model.TestModel.msl",
            };

            return conStringBuilder.ToString();
        }

        /// <summary>
        /// Register the derived data models.
        /// Called by the unit of work factory of the derived datamodel.
        /// </summary>
        /// <param name="childFactory">The unit of work factory of the derived data model.</param>
        /// <param name="childModel">The name of the derived data model.</param>
        public void RegisterChild(IUnitOfWorkFactory childFactory, string childModel)
        {
            _children[childModel] = childFactory;
        }

        #region IUnitOfWorkFactory Members

        /// <summary>
        /// Creates a new unit of work instance to access the data model.
        /// </summary>
        /// <param name="context">The dbcontext thought the data model.</param>
        /// <returns>Created unit of work.</returns>
        internal IUnitOfWork Create(Marvin.TestTools.Test.Model.Entities context) 
        {
            if (context == null)
                throw new InvalidOperationException("Context has not been initialized.");
            return new EntityFrameworkUnitOfWork(context, RepoBuilders); 
        }

        /// <summary>
        /// Creates a merged new unit of work instance to access the data model.
        /// </summary>
        /// <param name="context">The dbcontext thought the data model.</param>
        /// <param name="other">The unit of work of the model to merge with.</param>
        /// <returns>Created unit of work.</returns>
        internal IUnitOfWork CreateMerged(Marvin.TestTools.Test.Model.Entities context, IUnitOfWork other) 
        {
            if (context == null)
                throw new InvalidOperationException("Context has not been initialized.");
            return new EntityFrameworkMergedUnitOfWork(context, RepoBuilders, other); 
        }

        /// <summary>
        /// Creates a new unit of work instance to access the data model.
        /// </summary>
        /// <returns>Created unit of work.</returns>
        public IUnitOfWork Create()
        {
            var connection = !string.IsNullOrEmpty(_instanceId)
                ? Effort.EntityConnectionFactory.CreatePersistent(_instanceId, _connectionString)
                : Effort.EntityConnectionFactory.CreatePersistent(_connectionString);

            var context = new Marvin.TestTools.Test.Model.Entities(connection, ContextMode.AllOn);

            return Create(context);
        }

        /// <summary>
        /// Creates a new unit of work instance to access the data model.
        /// </summary>
        /// <param name="mode">The mode of the dbcontext. Decides witch behavior the entities you get will have.</param>
        /// <returns>Created unit of work.</returns>
        public IUnitOfWork Create(ContextMode mode)
        {
            var connection = !string.IsNullOrEmpty(_instanceId)
                ? Effort.EntityConnectionFactory.CreatePersistent(_instanceId, _connectionString)
                : Effort.EntityConnectionFactory.CreatePersistent(_connectionString);

            var context = new Marvin.TestTools.Test.Model.Entities(connection, mode);

            return Create(context);
        }

        /// <summary>
        /// Merges the given unit of work instance with a new instance for this model.
        /// </summary>
        /// <param name="other">The unit of work to merge.</param>
        /// <returns>Created unit of work with merged instance.</returns>
        public IUnitOfWork Merge(IUnitOfWork other)
        {
            return Merge(other, ContextMode.AllOn);
        }

        /// <summary>
        /// Merges the given unit of work instance with a new instance for this model.
        /// </summary>
        /// <param name="other">The unit of work to merge.</param>
        /// <param name="mode">The mode of the dbcontext. Decides witch behavior the entities you get will have.</param>
        /// <returns>Created unit of work with merged instance.</returns>
        public IUnitOfWork Merge(IUnitOfWork other, ContextMode mode)
        {
            var context = new Marvin.TestTools.Test.Model.Entities(_connectionString, mode);
            other.Mode = mode;
            return CreateMerged(context, other);
        }

        /// <summary>
        /// Get a child with a given type and name.
        /// </summary>
        /// <param name="targetType">The type this instance is assigned to - irrelevant for data models</param>
        /// <param name="name">The name of the child.</param>
        /// <returns>The child with the given type and name.</returns>
        public IUnitOfWorkFactory GetChild(string name, Type targetType)
        {
            if (string.IsNullOrEmpty(name))
               return this;
            // currently the only supported child-type is IUnitOfWorkFactory!
            return _children.ContainsKey(name) ? _children[name] : null;
        }
        #endregion
    }
}
