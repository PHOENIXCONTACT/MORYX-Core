//------------------------------------------------------------------------------
// This is auto-generated code.
//------------------------------------------------------------------------------
// This code was generated by Entity Developer tool using the Marvin template for generating Repositories and a Unit of Work for Entity Framework.
// If you have any questions or suggestions for improvement regarding this code, contact Thomas Fuchs. I allways need feedback to improve.
//
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated. So even when you think you can do better,
// don't touch it.
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Data.Entity.Core.EntityClient;
using System.Diagnostics;
using System.Text;
using Devart.Data.PostgreSql;
using System.Data.Entity.Core.Objects;
using System.Data.Entity;
using System.Reflection;
using Marvin.Modules;
using Marvin.Configuration;
using Marvin.Model;
using Marvin.TestTools.Test.Model; 

namespace Marvin.TestTools.TestMerge.Model
{
    internal delegate IRepository RepoBuilder(IUnitOfWork uow, DbContext context, IUnitOfWork parentUow);

    /// <summary>
    /// Factory to get a unit of work for the TestMerge model
    /// </summary>
    [ModelFactory("Marvin.TestTools.TestMerge.Model")]
    public class EntityFrameworkUnitOfWorkFactory : IUnitOfWorkFactory, IParentFactory, IInitializable
    {
        private string _connectionString;
        private readonly Dictionary<string, IUnitOfWorkFactory> _children = new Dictionary<string, IUnitOfWorkFactory>();

        /// <summary>
        /// Repository builder dictionary, to create new instances of 
        /// </summary>
        private static readonly Dictionary<Type, RepoBuilder> RepoBuilders = new Dictionary<Type, RepoBuilder>
        {
            { typeof(ISimpleChildRepository), SimpleChildRepository.Create },
            { typeof(IRepository<SimpleChild>), SimpleChildRepository.Create },
            { typeof(IEnhancedChildRepository), EnhancedChildRepository.Create },
            { typeof(IRepository<EnhancedChild>), EnhancedChildRepository.Create },
            { typeof(IMergedBaseTPTRepository), MergedBaseTPTRepository.Create },
            { typeof(IRepository<MergedBaseTPT>), MergedBaseTPTRepository.Create },
            { typeof(IMergedChildTPT1Repository), MergedChildTPT1Repository.Create },
            { typeof(IRepository<MergedChildTPT1>), MergedChildTPT1Repository.Create },
            { typeof(IMergedChildTPT2Repository), MergedChildTPT2Repository.Create },
            { typeof(IRepository<MergedChildTPT2>), MergedChildTPT2Repository.Create },
            { typeof(IMergedBaseTPHRepository), MergedBaseTPHRepository.Create },
            { typeof(IRepository<MergedBaseTPH>), MergedBaseTPHRepository.Create },
            { typeof(IMergedChildTPH1Repository), MergedChildTPH1Repository.Create },
            { typeof(IRepository<MergedChildTPH1>), MergedChildTPH1Repository.Create },
            { typeof(IMergedChildTPH2Repository), MergedChildTPH2Repository.Create },
            { typeof(IRepository<MergedChildTPH2>), MergedChildTPH2Repository.Create },
            { typeof(IMergedChildTPH2_1Repository), MergedChildTPH2_1Repository.Create },
            { typeof(IRepository<MergedChildTPH2_1>), MergedChildTPH2_1Repository.Create },
            { typeof(IMergedChildTPH2_2Repository), MergedChildTPH2_2Repository.Create },
            { typeof(IRepository<MergedChildTPH2_2>), MergedChildTPH2_2Repository.Create },
            { typeof(IMergedBaseTPCRepository), MergedBaseTPCRepository.Create },
            { typeof(IRepository<MergedBaseTPC>), MergedBaseTPCRepository.Create },
            { typeof(IMergedChildTPC1Repository), MergedChildTPC1Repository.Create },
            { typeof(IRepository<MergedChildTPC1>), MergedChildTPC1Repository.Create },
            { typeof(IMergedChildTPC2Repository), MergedChildTPC2Repository.Create },
            { typeof(IRepository<MergedChildTPC2>), MergedChildTPC2Repository.Create },
            { typeof(ITriggerTestRepository), TriggerTestRepository.Create },
            { typeof(IRepository<TriggerTest>), TriggerTestRepository.Create },
         };

        /// <summary>
        /// ConfigurationManager to get the connection settings through the database.
        /// Will be injected!
        /// </summary>
        public IConfigManager ConfigManager { get; set; }

        /// <summary>
        /// Factory of the TestModel model (where this model is inherited from).
        /// Will be injected!
        /// </summary>        
        [Container.Named(TestModelConstants.Namespace)]
        public IUnitOfWorkFactory ParentFactory { get; set; }

        /// <summary>
        /// Static instance for internal usage
        /// </summary>
        internal static EntityFrameworkUnitOfWorkFactory Instance { get; private set; }

        /// <summary>
        /// Prepare to use the factory to get a unit of work.
        /// Called by the IoC container.
        /// </summary>
        public void Initialize()
        {
            // Read config and build connection string
            ReloadConfiguration();

            // Set static for internal access
            Instance = this;

            // Register at the parent
            ((IParentFactory)ParentFactory).RegisterChild(this, "Marvin.TestTools.TestMerge.Model");
        }

        /// <summary>
        /// Load the current configurations and build the connection string 
        /// through the configured database.
        /// </summary>
        public void ReloadConfiguration()
        {
            var config = ConfigManager.GetConfiguration<DbConfig>();
            _connectionString = BuildConnectionString(config);
        }

        /// <summary>
        /// Build a connection string from config
        /// </summary>
        /// <param name="databaseConfig"></param>
        /// <returns></returns>
        private static string BuildConnectionString(IDatabaseConfig databaseConfig)
        {
            // Read given config and create connection string
            var conStringBuilder = new EntityConnectionStringBuilder
            {
                Metadata = "res://*/Marvin.TestTools.TestMerge.Model.Model.TestMerge.csdl|" +
                           "res://*/Marvin.TestTools.TestMerge.Model.Model.TestMerge.ssdl|" +
                           "res://*/Marvin.TestTools.TestMerge.Model.Model.TestMerge.msl",
            };

            var providerConStr = new PgSqlConnectionStringBuilder
            {
                UserId = databaseConfig.User,
                Password = databaseConfig.Password,
                Host = databaseConfig.Server,
                Port = databaseConfig.Port,
                Database = databaseConfig.Database,
                PersistSecurityInfo = true,
                Schema = databaseConfig.Schema,
                Unicode = true
            }.ToString();

            conStringBuilder.Provider = "Devart.Data.PostgreSql";
            conStringBuilder.ProviderConnectionString = providerConStr;
            return conStringBuilder.ToString();
        }

        /// <summary>
        /// Register the derived data models.
        /// Called by the unit of work factory of the derived datamodel.
        /// </summary>
        /// <param name="childFactory">The unit of work factory of the derived data model.</param>
        /// <param name="childModel">The name of the derived data model.</param>
        public void RegisterChild(IUnitOfWorkFactory childFactory, string childModel)
        {
            _children[childModel] = childFactory;
        }

        #region IUnitOfWorkFactory Members

        /// <summary>
        /// Creates a new unit of work instance to access the data model.
        /// </summary>
        /// <param name="context">The dbcontext thought the data model.</param>
        /// <param name="parentUow">The unit of work of the base data model.</param>
        /// <param name="forward">Forward the creation commands through the base datamodel.</param>
        /// <returns>Created unit of work.</returns>
        internal IUnitOfWork Create(Marvin.TestTools.TestMerge.Model.Entities context, IUnitOfWork parentUow, bool forward) 
        {
            if (context == null)
                throw new InvalidOperationException("Context has not been initialized.");
            return new EntityFrameworkUnitOfWork(context, RepoBuilders, parentUow) { ForwardToParent = forward }; 
        }

        /// <summary>
        /// Creates a merged new unit of work instance to access the data model.
        /// </summary>
        /// <param name="context">The dbcontext thought the data model.</param>
        /// <param name="parentUow">The unit of work of the base data model.</param>
        /// <param name="other">The unit of work of the model to merge with.</param>
        /// <returns>Created unit of work.</returns>
        internal IUnitOfWork CreateMerged(Marvin.TestTools.TestMerge.Model.Entities context, IUnitOfWork parentUow, IUnitOfWork other) 
        {
            if (context == null)
                throw new InvalidOperationException("Context has not been initialized.");
            return new EntityFrameworkMergedUnitOfWork(context, RepoBuilders, parentUow, other); 
        }

        /// <summary>
        /// Creates a new unit of work instance to access the data model.
        /// </summary>
        /// <returns>Created unit of work.</returns>
        public IUnitOfWork Create()
        {
            var callingClass = new StackFrame(1).GetMethod().DeclaringType;
            var bundleAtt = callingClass.Assembly.GetCustomAttribute<BundleAttribute>();
            // Check if the calling assembly has a bundle attribute with a matching bundle name.
            // A bundles datamodels should be used bundle-internally only.
            if (bundleAtt == null || (!bundleAtt.IsFrameworkComponent && bundleAtt.Bundle != "Marvin.TestTools.TestMerge"))
                throw new UnauthorizedAccessException("Access to the datamodel is restriced to components of the \"Marvin.TestTools.TestMerge\"  bundle!");

            var context = new Marvin.TestTools.TestMerge.Model.Entities(_connectionString, ContextMode.AllOn);

            return Create(context, ParentFactory.Create(), true);
        }

        /// <summary>
        /// Creates a new unit of work instance to access the data model.
        /// </summary>
        /// <param name="mode">The mode of the dbcontext. Decides witch behavior the entities you get will have.</param>
        /// <returns>Created unit of work.</returns>
        public IUnitOfWork Create(ContextMode mode)
        {
            var callingClass = new StackFrame(1).GetMethod().DeclaringType;
            var bundleAtt = callingClass.Assembly.GetCustomAttribute<BundleAttribute>();
            // Check if the calling assembly has a bundle attribute with a matching bundle name.
            // A bundles datamodels should be used bundle-internally only.
            if (bundleAtt == null || (!bundleAtt.IsFrameworkComponent && bundleAtt.Bundle != "Marvin.TestTools.TestMerge"))
                throw new UnauthorizedAccessException("Access to the datamodel is restriced to components of the \"Marvin.TestTools.TestMerge\"  bundle!");

            var context = new Marvin.TestTools.TestMerge.Model.Entities(_connectionString, mode);

            return Create(context, ParentFactory.Create(mode), true);
        }

        /// <summary>
        /// Merges the given unit of work instance with a new instance for this model.
        /// </summary>
        /// <param name="other">The unit of work to merge.</param>
        /// <returns>Created unit of work with merged instance.</returns>
        public IUnitOfWork Merge(IUnitOfWork other)
        {
            return Merge(other, ContextMode.AllOn);
        }

        /// <summary>
        /// Merges the given unit of work instance with a new instance for this model.
        /// </summary>
        /// <param name="other">The unit of work to merge.</param>
        /// <param name="mode">The mode of the dbcontext. Decides witch behavior the entities you get will have.</param>
        /// <returns>Created unit of work with merged instance.</returns>
        public IUnitOfWork Merge(IUnitOfWork other, ContextMode mode)
        {
            var context = new Marvin.TestTools.TestMerge.Model.Entities(_connectionString, mode);
            other.Mode = mode;
            var isParent = other.GetType().Namespace == "Marvin.TestTools.Test.Model";
            if (isParent)
              return Create(context, other, false);
            else
              return CreateMerged(context, ParentFactory.Create(), other);
        }

        /// <summary>
        /// Get a child with a given type and name.
        /// </summary>
        /// <param name="targetType">The type this instance is assigned to - irrelevant for data models</param>
        /// <param name="name">The name of the child.</param>
        /// <returns>The child with the given type and name.</returns>
        public IUnitOfWorkFactory GetChild(string name, Type targetType)
        {
            if (string.IsNullOrEmpty(name))
               return this;
            // currently the only supported child-type is IUnitOfWorkFactory!
            return _children.ContainsKey(name) ? _children[name] : null;
        }
        #endregion
    }
}
