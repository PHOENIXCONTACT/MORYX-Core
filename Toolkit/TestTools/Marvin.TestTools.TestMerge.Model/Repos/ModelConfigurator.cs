//------------------------------------------------------------------------------
// This is auto-generated code.
//------------------------------------------------------------------------------
// This code was generated by Entity Developer tool using the Marvin template for generating Repositories and a Unit of Work for Entity Framework.
// If you have any questions or suggestions for improvement regarding this code, contact Thomas Fuchs. I allways need feedback to improve.
//
// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated. So even when you think you can do better,
// don't touch it.
//------------------------------------------------------------------------------
using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Collections.Generic;
using System.Data.Entity.Core.EntityClient;
using Castle.MicroKernel.Registration;
using Castle.Windsor;
using Devart.Common;
using Devart.Data.PostgreSql;
using Marvin.Configuration;
using Marvin.Model;
using Marvin.TestTools.Test.Model;

namespace Marvin.TestTools.TestMerge.Model
{
    /// <summary>
    /// Database configurator for TestMerge
    /// </summary>
    [ModelConfigurator]
    public class ModelConfigurator : IModelConfigurator
    {    
        /// <summary>
        /// Configmanager to get the configuration.
        /// Will be injected!
        /// </summary>
        public IConfigManager ConfigManager { get; set; }

        /// <summary>
        /// Gets or sets the factory of the base model.
        /// </summary>
        [Container.Named(TestModelConstants.Namespace)] 
        public IUnitOfWorkFactory ParentFactory { get; set; }

        /// <summary>
        /// Target model of this configurator
        /// </summary>
        public string TargetModel { get { return "Marvin.TestTools.TestMerge.Model"; } }

		/// <summary>
        /// Target model of this configurator
        /// </summary>
        public IDatabaseConfig Config { get { return ConfigManager.GetConfiguration<DbConfig>(true); } }

        /// <summary>
        /// Factory responsible for this data model
        /// </summary>
        public IUnitOfWorkFactory ResponsibleFactory 
        { 
            get { return EntityFrameworkUnitOfWorkFactory.Instance; }
        }

        /// <summary>
        /// Windsor Container for Setup resolution
        /// </summary>
        private readonly IWindsorContainer _container;

        /// <summary>
        /// Default constructor
        /// </summary>
        public ModelConfigurator() 
        {
            _container = new WindsorContainer();
            // Install updates
            _container.Register(Classes.FromAssembly(GetType().Assembly)
                                .IncludeNonPublicTypes()
                                .BasedOn<IDatabaseUpdate>()
                                .WithServiceBase());

            // Install setups from assembly as well as the setups directory
            _container.Register(Classes.FromAssembly(GetType().Assembly)
                                .IncludeNonPublicTypes()
                                .BasedOn<IModelSetup>()
                                .WithServiceBase());
            _container.Register(Classes.FromAssemblyInDirectory(new AssemblyFilter(@".\ModelSetups"))
                               .BasedOn<IModelSetup>()
                               .If(setupType => setupType.GetCustomAttributes<ModelSetupAttribute>(false).Any(att => att.TargetModelNamespace == "Marvin.TestTools.TestMerge.Model"))
                               .WithServiceBase().WithServiceSelf());
			
            // Register creation scripts
			      _container.Register(Classes.FromAssembly(GetType().Assembly)
								               .IncludeNonPublicTypes()
								               .BasedOn<IDatabaseScript>()
								               .WithServiceBase());
        }

        /// <summary>
        /// Build a connection string from config
        /// </summary>
        /// <param name="databaseConfig"></param>
        /// <returns></returns>
        private static string BuildConnectionString(IDatabaseConfig databaseConfig)
        {
            // Read given config and create connection string
            var conStringBuilder = new EntityConnectionStringBuilder
            {
                Metadata = "res://*/Marvin.TestTools.TestMerge.Model.Model.TestMerge.csdl|" +
                           "res://*/Marvin.TestTools.TestMerge.Model.Model.TestMerge.ssdl|" +
                           "res://*/Marvin.TestTools.TestMerge.Model.Model.TestMerge.msl",
            };

            var providerConStr = new PgSqlConnectionStringBuilder
            {
                UserId = databaseConfig.User,
                Password = databaseConfig.Password,
                Host = databaseConfig.Server,
                Port = databaseConfig.Port,
                Database = databaseConfig.Database,
                PersistSecurityInfo = true,
                Schema = databaseConfig.Schema,
                Unicode = true
            }.ToString();

            conStringBuilder.Provider = "Devart.Data.PostgreSql";
            conStringBuilder.ProviderConnectionString = providerConStr;
            return conStringBuilder.ToString();
        }

        /// <summary>
        /// Tests the connection to a given database.
        /// </summary>
        /// <param name="config">Config describing the database target.</param>
        /// <returns><c>True</c> whether the database exists and the connection succeedes or <c>false</c> if not.</returns>
        public bool TestConnection(IDatabaseConfig config)
        {
            var context = new Entities(BuildConnectionString(config), ContextMode.AllOff);
            try
            {
                return context.Database.Exists();
            }
            catch
            {
                return false;
            }
            finally
            {
                context.Dispose();
            }
        }

        /// <summary>
        /// Create a new database for this model with given config
        /// </summary>
        /// <param name="config">Config describing the database target.</param>
        public void CreateDatabase(IDatabaseConfig config)
        {
            using (var context = new Entities(BuildConnectionString(config), ContextMode.AllOff))
            {
                // Check if this database is present on the server
                var dbExists = false;
                var pgConnection = new PgSqlConnection(PgConnectionString(config, false));
                var pgCommand = new PgSqlCommand("SELECT datname from pg_database;", pgConnection);

                // Open connection, execute command and close reader again
                pgConnection.Open();
                var reader = pgCommand.ExecuteReader();
                while (reader.Read())
                {
                    var dbName = reader.GetString("datname");
                    if (dbName != config.Database) 
                        continue;
                    
                    dbExists = true;
                    break;
                }
                reader.Close();
                pgConnection.Close();
                if(dbExists && context.Database.Exists())
                    return;


                // Create connection and prepare command if the database does not exist at all
                if (!dbExists)
                {
                    // Create connection and create DB
                    pgConnection = new PgSqlConnection(PgConnectionString(config, false));
                    pgConnection.Open();
                    pgCommand = new PgSqlCommand(string.Format("CREATE DATABASE \"{0}\"", config.Database), pgConnection);
                    pgCommand.ExecuteNonQuery();
                    pgConnection.Close();

                    // Create metadata table
                    pgConnection = new PgSqlConnection(PgConnectionString(config, true));
                    pgConnection.Open();
                    pgCommand = new PgSqlCommand(@"CREATE TABLE metadata (id bigserial, namespace varchar, version integer, location varchar, PRIMARY KEY (id))", pgConnection);
                    pgCommand.ExecuteNonQuery();
                    pgConnection.Close();
                }

                // Insert version into metadata table
                pgConnection = new PgSqlConnection(PgConnectionString(config, true));
                pgConnection.Open();
                pgCommand = new PgSqlCommand(string.Format("INSERT INTO metadata (namespace, version) VALUES ('{0}', {1})", "Marvin.TestTools.TestMerge.Model", 42), pgConnection); 
                pgCommand.ExecuteNonQuery();
                pgConnection.Close();

                // Fill new db
                context.Database.Create();

				// Execute additional scripts on our new database
				pgConnection = new PgSqlConnection(PgConnectionString(config, true));
				foreach(var script in _container.ResolveAll<IDatabaseScript>().Where(r => r.IsCreationScript))
				{
					var databaseScript = new PgSqlScript(script.GetText(), pgConnection);
					pgConnection.Open();
					databaseScript.Execute();
					pgConnection.Close();
				}
            }        
        }


        /// <summary>
        /// Updates the database to the latest version
        /// </summary>
        /// <returns></returns>
        public UpdateSummary UpdateDatabase()
        {
            var config = ConfigManager.GetConfiguration<DbConfig>();

            var currentVersion = GetVersion(config);
            if (currentVersion == 42) 
                return new UpdateSummary();

            var updates = _container.ResolveAll<IDatabaseUpdate>().Where(update => update.From >= currentVersion)
                                                                  .OrderBy(update => update.From).ToArray();

            // Validate a consistent update path
            var version = currentVersion;
            foreach (var update in updates)
            {
                if(update.From > version)
                    throw new Exception(string.Format("No update supports transition from database version {0} to {1}", version, version + 1));
                version = update.To;
            }
            if(version < 42)
                throw new Exception(string.Format("Missing update! Last found update: {0} - Model version: {1}", version, 42)); 
            
            foreach (var update in updates)
            {
                update.Update(new UpdateContext(config));
            }
            SetVersion(config);

            return new UpdateSummary
            {
                WasUpdated = true,
                ExecutedUpdates = updates
            };
        }

        private class UpdateContext : IUpdateContext
        {
            private readonly IDatabaseConfig _config;

            public UpdateContext(IDatabaseConfig config)
            {
                _config = config;
            }

            /// <summary>
            /// Open a new unit of work to access the model
            /// </summary>
            /// <returns></returns>
            public IUnitOfWork OpenUnitOfWork()
            {
                return EntityFrameworkUnitOfWorkFactory.Instance.Create();
            }

            /// <summary>
            /// Execute sql commands
            /// </summary>
            public void ExecuteSql(string sqlText)
            {
                ExecuteCommand(_config, sqlText);
            }

            /// <summary>
            /// Execute embedded script located in folder scripts
            /// </summary>
            public void ExecuteScript(string fileName)
            {
                var path = "Marvin.TestTools.TestMerge.Model.Updates." + fileName;
                using (Stream stream = GetType().Assembly.GetManifestResourceStream(path))
                using (StreamReader reader = new StreamReader(stream))
                {
                    ExecuteCommand(_config, reader.ReadToEnd());
                }
            }
        }


        /// <summary>
        /// Fetch current version
        /// </summary>
        private static int GetVersion(IDatabaseConfig config)
        {
            var connection = new PgSqlConnection(PgConnectionString(config, true));
            var command = new PgSqlCommand(string.Format("SELECT version FROM metadata WHERE namespace = '{0}'", "Marvin.TestTools.TestMerge.Model"), connection);

            connection.Open();
            var version = (int)command.ExecuteScalar();
            connection.Close();
            return version;
        }

        /// <summary>
        ///  Set current version of this model
        /// </summary>
        private static void SetVersion(IDatabaseConfig config)
        {
            ExecuteCommand(config, string.Format("UPDATE metadata SET version = {0} WHERE namespace = '{1}'", 
                                                 42, "Marvin.TestTools.TestMerge.Model"));
        }

        /// <summary>
        /// Execute SQL command
        /// </summary>
        private static void ExecuteCommand(IDatabaseConfig config, string commandText)
        {
            var connection = new PgSqlConnection(PgConnectionString(config, true));
            var command = new PgSqlCommand(commandText, connection);

            connection.Open();
            command.ExecuteNonQuery();
            connection.Close();
        }

        /// <summary>
        /// Delete the database configured in the <see cref="IDatabaseConfig"/>.
        /// </summary>
        /// <param name="config">Config describing the database target.</param>
        public void DeleteDatabase(IDatabaseConfig config)
        {
            // Close all connections to the server. 
            // DevArt uses connection pooling to enable faster querys. 
            // Its not posible to delete the database while there are open connections.
            PgSqlConnection.ClearAllPools(true);

            // Create connection and prepare command
            var pgConnection = new PgSqlConnection(PgConnectionString(config, false));
            var pgCommand = new PgSqlCommand(string.Format("DROP DATABASE \"{0}\";", config.Database), pgConnection);

            // Open connection, execute command and close reader again
            pgConnection.Open();
            pgCommand.ExecuteReader().Close();
            pgConnection.Close();
        }

        /// <summary>
        /// Dump the database und save the backup at <c>filePath</c>/>
        /// This method works asynchronus
        /// </summary>
        /// <param name="config">Config describing the database target</param>
        /// <param name="filePath">Path to store backup</param>
        /// <returns>True if Backup is in progress</returns>
        public void DumpDatabase(IDatabaseConfig config, string filePath)
		{
			DatabaseDumpOperation(config, pgDump => pgDump.Backup(filePath));
		}

		/// <summary>
        /// Restore this database with the given backup file
        /// </summary>
        /// <param name="config">Config to use</param><param name="filePath">Filepath of dump</param>
        public void RestoreDatabase(IDatabaseConfig config, string filePath)
		{
			DatabaseDumpOperation(config, pgDump => pgDump.Restore(filePath));
		}

		private void DatabaseDumpOperation(IDatabaseConfig config, Action<PgSqlDump> dumpOperation)
        {
            // First make sure db exists and belongs to this model
            if (!TestConnection(config))
                throw new Exception(string.Format("Database {0} does not exist!", config.Database));

            // Prepare connection
            var connection = new PgSqlConnection(PgConnectionString(config, true));
            connection.Open();
            var pgSqlDump = new PgSqlDump(connection) { Mode = DumpMode.All, UseMultirowSyntax = true, IncludeDrop = true };

            // Execute dump operation DB async
		    dumpOperation(pgSqlDump);
            connection.Close();
        }

		private static string PgConnectionString(IDatabaseConfig config, bool includeDatabase)
		{
			return includeDatabase
				? string.Format("Host={0}; Port={1}; User Id={2}; Password={3}; Database={4}", config.Server, config.Port, config.User, config.Password, config.Database)
				: string.Format("Host={0}; Port={1}; User Id={2}; Password={3}", config.Server, config.Port, config.User, config.Password);
		}

        /// <summary>
        /// Get all setups for this model
        /// </summary>
        /// <returns></returns>
        public IEnumerable<IModelSetup> GetAllSetups()
        {
            return _container.ResolveAll<IModelSetup>();
        }

        /// <summary>
        /// Get all scripts of this model
        /// </summary>
        public IEnumerable<IDatabaseScript> GetAllScripts()
        {
            return _container.ResolveAll<IDatabaseScript>();
        }

        /// <summary>
        /// Execute setup for this config
        /// </summary>
        /// <param name="config">Config</param>
        /// <param name="setup">Setup</param>
        /// <param name="setupData"></param>
        public void Execute(IDatabaseConfig config, IModelSetup setup, string setupData)
        {
            var context = new Entities(BuildConnectionString(config), ContextMode.AllOn);
            using (var unitOfWork = (EntityFrameworkUnitOfWorkFactory.Instance).Create(context, ParentFactory.Create(), true)) 
            {
                setup.Execute(unitOfWork, setupData);
            }
        }
    }
}
